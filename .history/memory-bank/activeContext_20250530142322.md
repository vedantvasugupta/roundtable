# Active Context: Current Work and Focus

## Current Task

*   **Stabilizing Core Voting Loop:** The immediate focus is on ensuring the end-to-end process of proposal creation, approval, DM-based voting, and result calculation/termination is stable for Plurality and Approval voting mechanisms. This involves addressing bugs as they arise from testing.
*   **Memory Bank Update:** Updating all memory bank files to reflect recent fixes and current project state.

## Recent Significant Changes

*   **DM Voting Logic Implementation & Bug Fixing:**
    *   Added logic to `proposals.py` (`_perform_approve_proposal_action`) to send DMs to eligible voters when a proposal is approved. This includes fetching proposal details, options, eligible voters, calling `voting.send_voting_dm`, and recording invites with `db.add_voting_invite`.
    *   Addressed a `TypeError` in `proposals.py` related to `db.get_proposal_options` returning a list of strings instead of dicts (fixed in `_perform_approve_proposal_action` during DM preparation).
    *   Defined the missing `process_vote` function in `voting.py` to handle vote submissions from DMs and record them using `db.record_vote`.
    *   Fixed an `AttributeError` in `ApprovalVoteView` (in `voting.py`) by correcting the check for selected options from `self.selected_option` to `self._approved_options`.
    *   Resolved a `TypeError` in `ApprovalVoting.count_votes` (in `voting_utils.py`) by updating its method signature to accept `options` and `hyperparameters` and by initializing its results dictionary with all official options.

*   **General Stability Improvements:** Continued to refine error handling and logging based on issues encountered during testing.

## Next Steps (Immediate & Short-Term)

*   **Thorough Testing:**
    *   **Plurality Voting:** Full lifecycle test (creation, approval, DM voting by multiple users, abstention, deadline expiry/manual termination, result accuracy).
    *   **Approval Voting:** Full lifecycle test (creation, approval, DM voting with multiple selections, abstention, deadline expiry/manual termination, result accuracy).
    *   **Borda Count & Runoff Voting:** Begin implementing and testing the interactive DM voting views (`RankedVoteView`) and ensure their `count_votes` methods in `voting_utils.py` are correctly handling ranked data and any specific hyperparameters.
    *   **D'Hondt Method:** Verify DM voting (likely uses `PluralityVoteView`) and ensure `count_votes` and result formatting are clear, especially regarding its typical multi-winner nature versus single-winner proposal outcomes.
*   **Review `db.record_vote` and `process_vote` for Early Closure:** Consider if the logic for checking 100% voter turnout and potentially triggering early proposal closure should be implemented within or called from `process_vote` in `voting.py`. This needs careful thought regarding guild context availability for `get_eligible_voters`.
*   **Hyperparameter Utilization:** Systematically review each voting mechanism's `count_votes` method in `voting_utils.py` to ensure any relevant hyperparameters (e.g., `winning_threshold` for Plurality, `num_seats` for D'Hondt) are being correctly retrieved from the `hyperparameters` argument and applied.

## Active Decisions & Considerations

*   **Early Proposal Closure:** How and when to trigger early closure if all eligible/invited users have voted. Doing this from `process_vote` is complex due to context. A background task or a check during `update_vote_tracking` might be more suitable.
*   **Clarity of D'Hondt Results:** Ensure the presentation of D'Hondt results is understandable, especially if it's used for single-winner scenarios.

## Important Patterns & Preferences

*   **Iterative Debugging:** Addressing issues as they appear through testing logs and user feedback.
*   **Memory Bank Upkeep:** Regularly updating documentation to reflect the latest state of the codebase and understanding.